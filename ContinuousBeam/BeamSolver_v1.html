<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Stressjock's Almost-Pro Continuous Beam Analysis v7</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg: #03436c; 
            --panel: #ffffff; 
            --accent: #0b64a0; 
            --muted: #6b7280;
            --card-shadow: 0 2px 8px rgba(15,23,42,0.15);
            --radius: 8px;
            --danger: #d93025;
            --moment: #8b5cf6;
        }
        html, body { height: 100%; margin: 0; font-family: Inter, "Segoe UI", Roboto, Arial; background: var(--bg); color: #111; }
        header { background: linear-gradient(90deg, var(--accent), #0870b0); color: white; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between; }
        header h1 { margin: 0; font-size: 16px; font-weight: 600; }
        
        .app { display: flex; flex-wrap: wrap; gap: 12px; padding: 14px; box-sizing: border-box; max-width: 1400px; margin: 0 auto; }
        .panel { background: var(--panel); border-radius: var(--radius); box-shadow: var(--card-shadow); padding: 16px; }
        
        .controls { flex: 0 0 460px; display: flex; flex-direction: column; gap: 15px; }
        .viz-panel { flex: 1; min-width: 500px; }
        .results-grid { flex: 0 0 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 10px; }

        #canvas-wrapper { width: 100%; height: 240px; background: #fff; border: 1px solid #e5e7eb; border-radius: 4px; position: relative; margin-bottom: 10px; }
        canvas#beamCanvas { width: 100%; height: 100%; display: block; }

        h2 { font-size: 14px; color: var(--accent); border-bottom: 1px solid #e5e7eb; padding-bottom: 6px; margin: 0 0 12px 0; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        
        table { width: 100%; border-collapse: collapse; font-size: 11px; margin-bottom: 10px; }
        th { background: #f8f9fa; color: var(--muted); padding: 6px 4px; text-align: center; font-weight: 600; border-bottom: 2px solid #eee; }
        td { border-bottom: 1px solid #f0f0f0; padding: 4px; text-align: center; }
        
        input, select { padding: 4px; border: 1px solid #ccc; border-radius: 4px; font-size: 11px; width: 85%; }
        .id-cell { font-weight: bold; color: var(--muted); width: 25px; }

        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
        .btn { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; transition: background 0.2s; }
        .btn-add { background: #f0fdf4; color: #166534; border: 1px solid #bbf7d0; }
        .btn-solve { background: var(--accent); color: white; margin-left: auto; padding: 8px 24px; }
        .btn-solve:hover { background: #0870b0; }
        .btn-io { background: #fff; border: 1px solid #d1d5db; color: #374151; }
        .btn-del { color: var(--danger); background: none; font-size: 16px; padding: 0 5px; }

        .chart-container { height: 220px; position: relative; padding: 10px; border: 1px solid #f0f0f0; border-radius: 4px; }
        .chart-label { position: absolute; top: 5px; left: 10px; font-size: 10px; font-weight: 700; color: var(--muted); pointer-events: none; }

        .reactions-card { background: #f8fafc; border-left: 4px solid var(--accent); padding: 12px; margin-top: 15px; display: none; border-radius: 4px; }
        .reactions-grid { display: flex; gap: 10px; flex-wrap: wrap; font-size: 12px; margin-top: 8px; }
        .reaction-item { background: white; padding: 4px 8px; border-radius: 4px; border: 1px solid #e2e8f0; font-family: monospace; }

        .error-msg { 
            color: #b91c1c; background: #fef2f2; border: 1px solid #fee2e2; 
            padding: 12px; border-radius: 4px; font-size: 13px; margin-bottom: 15px; display: none;
            line-height: 1.5;
        }
    </style>
</head>
<body>

<header>
    <h1>Stressjocks's Almost-Pro Continuous Beam Analysis</h1>
</header>

<div class="app">
    <div class="panel controls">
        <div>
            <h2>Nodes & Constraints</h2>
            <table id="nodeTable">
                <thead><tr><th>ID</th><th>x (in)</th><th>Support</th><th>P (lb)</th><th>M (lb-in)</th><th></th></tr></thead>
                <tbody oninput="updateVisualization()">
                    <tr><td class="id-cell">1</td><td><input type="number" class="nx" value="0"></td><td><select class="nc"><option value="fixed">Fixed</option><option value="pin">Pin</option><option value="roller">Roller</option><option value="none">None</option></select></td><td><input type="number" class="np" value="0"></td><td><input type="number" class="nm" value="0"></td><td></td></tr>
                    <tr><td class="id-cell">2</td><td><input type="number" class="nx" value="60"></td><td><select class="nc"><option value="none" selected>None</option><option value="pin">Pin</option><option value="roller">Roller</option><option value="fixed">Fixed</option></select></td><td><input type="number" class="np" value="-1000"></td><td><input type="number" class="nm" value="0"></td><td><button class="btn-del" onclick="removeRow(this)">×</button></td></tr>
                    <tr><td class="id-cell">3</td><td><input type="number" class="nx" value="120"></td><td><select class="nc"><option value="none">None</option><option value="pin">Pin</option><option value="roller" selected>Roller</option><option value="fixed">Fixed</option></select></td><td><input type="number" class="np" value="0"></td><td><input type="number" class="nm" value="0"></td><td><button class="btn-del" onclick="removeRow(this)">×</button></td></tr>
                </tbody>
            </table>
            <div class="btn-group">
                <button class="btn btn-add" onclick="addRow()">+ Add Node</button>
                <button class="btn btn-io" onclick="manualSort()">Sort Nodes</button>
            </div>
        </div>

        <div>
            <h2>Span Properties</h2>
            <table id="spanTable">
                <thead><tr><th>Span</th><th>E (psi)</th><th>I (in⁴)</th><th>ȳ (in)</th><th>q1</th><th>q2</th></tr></thead>
                <tbody id="spanBody" oninput="updateVisualization()"></tbody>
            </table>
            <div class="btn-group">
                <button class="btn btn-io" onclick="exportToCSV()">Save CSV</button>
                <button class="btn btn-io" onclick="document.getElementById('file-input').click()">Load</button>
                <input type="file" id="file-input" accept=".csv" style="display:none" onchange="importFromCSV(event)">
                <button class="btn btn-solve" onclick="runAnalysis()">SOLVE SYSTEM</button>
            </div>
        </div>

        <div id="reactionsDisplay" class="reactions-card">
            <h2 style="border:none; margin-bottom:5px;">Reactions</h2>
            <div id="reactionsList" class="reactions-grid"></div>
        </div>
    </div>

    <div class="panel viz-panel">
        <h2>Beam Visualization</h2>
        <div id="canvas-wrapper"><canvas id="beamCanvas"></canvas></div>
        
        <div id="stabilityError" class="error-msg"></div>

        <div class="theory-section" style="font-size: 12px; color: var(--muted); line-height: 1.4;">
            <p>Direct Stiffness Method analysis. Purple arcs represent applied moments. Black dots indicate analytical nodes.</p>
        </div>
    </div>

    <div class="results-grid">
        <div class="panel chart-container"><div class="chart-label">DISPLACEMENT (in)</div><canvas id="dispChart"></canvas></div>
        <div class="panel chart-container"><div class="chart-label">SHEAR FORCE (lb)</div><canvas id="shearChart"></canvas></div>
        <div class="panel chart-container"><div class="chart-label">BENDING MOMENT (lb-in)</div><canvas id="momentChart"></canvas></div>
        <div class="panel chart-container"><div class="chart-label">BENDING STRESS (psi)</div><canvas id="stressChart"></canvas></div>
    </div>
</div>

<script>
let charts = {};
let nextId = 4;

function formatVal(v) {
    const absV = Math.abs(v);
    if (absV === 0) return "0";
    if (absV < 0.01 || absV > 100000) return v.toExponential(2);
    return v.toFixed(3).replace(/\.?0+$/, "");
}

function updateVisualization() {
    const nodeRows = document.querySelectorAll("#nodeTable tbody tr").length;
    syncSpanTableRows(nodeRows - 1);
    const data = getData();
    drawInputBeam(data.sortedNodes, data.spans);
    document.getElementById("stabilityError").style.display = "none";
}

function addRow() {
    const tbody = document.querySelector("#nodeTable tbody");
    const lastX = parseFloat(tbody.lastElementChild.querySelector(".nx").value) || 0;
    const row = tbody.insertRow();
    row.innerHTML = `<td class="id-cell">${nextId++}</td><td><input type="number" class="nx" value="${lastX + 50}"></td><td><select class="nc"><option value="none" selected>None</option><option value="pin">Pin</option><option value="roller">Roller</option><option value="fixed">Fixed</option></select></td><td><input type="number" class="np" value="0"></td><td><input type="number" class="nm" value="0"></td><td><button class="btn-del" onclick="removeRow(this)">×</button></td>`;
    updateVisualization();
}

function removeRow(btn) {
    const tbody = document.querySelector("#nodeTable tbody");
    if (tbody.rows.length > 2) {
        btn.closest('tr').remove();
        updateVisualization();
    } else {
        alert("Beam must have at least 2 nodes.");
    }
}

function manualSort() {
    let data = getData();
    data.nodes.sort((a, b) => a.x - b.x);
    const nBody = document.getElementById("nodeTable").querySelector("tbody");
    nBody.innerHTML = "";
    data.nodes.forEach((nd, i) => {
        const row = nBody.insertRow();
        const delBtn = i === 0 ? '' : `<button class="btn-del" onclick="removeRow(this)">×</button>`;
        row.innerHTML = `<td class="id-cell">${nd.id}</td><td><input type="number" class="nx" value="${nd.x}"></td><td><select class="nc"><option value="none" ${nd.type=='none'?'selected':''}>None</option><option value="pin" ${nd.type=='pin'?'selected':''}>Pin</option><option value="roller" ${nd.type=='roller'?'selected':''}>Roller</option><option value="fixed" ${nd.type=='fixed'?'selected':''}>Fixed</option></select></td><td><input type="number" class="np" value="${nd.P}"></td><td><input type="number" class="nm" value="${nd.M}"></td><td>${delBtn}</td>`;
    });
    updateVisualization();
}

function syncSpanTableRows(needed) {
    const tbody = document.getElementById("spanBody");
    while (tbody.rows.length < needed) {
        const r = tbody.insertRow();
        r.innerHTML = `<td>-</td><td><input type="number" class="se" value="29e6"></td><td><input type="number" class="si" value="100"></td><td><input type="number" class="sy" value="5"></td><td><input type="number" class="sq1" value="0"></td><td><input type="number" class="sq2" value="0"></td>`;
    }
    while (tbody.rows.length > needed) tbody.deleteRow(-1);
    const nodes = [];
    document.querySelectorAll("#nodeTable tbody tr").forEach(row => {
        nodes.push({ id: row.cells[0].innerText, x: parseFloat(row.querySelector(".nx").value) || 0 });
    });
    nodes.sort((a, b) => a.x - b.x);
    for (let i = 0; i < tbody.rows.length; i++) {
        if(nodes[i] && nodes[i+1]) tbody.rows[i].cells[0].innerText = `${nodes[i].id}-${nodes[i+1].id}`;
    }
}

function getData() {
    let nodes = [];
    document.querySelectorAll("#nodeTable tbody tr").forEach(row => {
        nodes.push({ id: row.cells[0].innerText, x: parseFloat(row.querySelector(".nx").value)||0, type: row.querySelector(".nc").value, P: parseFloat(row.querySelector(".np").value)||0, M: parseFloat(row.querySelector(".nm").value)||0 });
    });
    let sortedNodes = [...nodes].sort((a, b) => a.x - b.x);
    let spans = [];
    const sRows = document.querySelectorAll("#spanTable tbody tr");
    sortedNodes.forEach((nd, i) => {
        if (i < sortedNodes.length - 1) {
            let row = sRows[i];
            spans.push({
                label: (row && row.cells[0]) ? row.cells[0].innerText : `${sortedNodes[i].id}-${sortedNodes[i+1].id}`,
                E: row ? parseFloat(row.querySelector(".se").value) : 29e6,
                I: row ? parseFloat(row.querySelector(".si").value) : 100,
                y: row ? parseFloat(row.querySelector(".sy").value) : 5,
                q1: row ? parseFloat(row.querySelector(".sq1").value) : 0,
                q2: row ? parseFloat(row.querySelector(".sq2").value) : 0
            });
        }
    });
    return { nodes, sortedNodes, spans };
}

function solveLinear(A, b) {
    const n = b.length;
    for (let i = 0; i < n; i++) {
        let max = i;
        for (let j = i + 1; j < n; j++) if (Math.abs(A[j][i]) > Math.abs(A[max][i])) max = j;
        [A[i], A[max]] = [A[max], A[i]]; [b[i], b[max]] = [b[max], b[i]];
        if (Math.abs(A[i][i]) < 1e-18) continue;
        for (let j = i + 1; j < n; j++) {
            const m = A[j][i] / A[i][i];
            for (let k = i; k < n; k++) A[j][k] -= m * A[i][k];
            b[j] -= m * b[i];
        }
    }
    const x = new Array(n).fill(0);
    for (let i = n - 1; i >= 0; i--) {
        let s = 0;
        for (let j = i + 1; j < n; j++) s += A[i][j] * x[j];
        x[i] = (b[i] - s) / A[i][i];
    }
    return x;
}

function runAnalysis() {
    const { sortedNodes, spans } = getData();
    const errorDiv = document.getElementById("stabilityError");
    errorDiv.style.display = "none";

    // --- Geometry Divide-by-Zero Check ---
    for (let i = 0; i < sortedNodes.length - 1; i++) {
        const L = sortedNodes[i+1].x - sortedNodes[i].x;
        if (Math.abs(L) < 1e-6) {
            errorDiv.innerHTML = `<strong>Geometry Error:</strong> Nodes ${sortedNodes[i].id} and ${sortedNodes[i+1].id} are at the same position. <br>Please move one node (min 0.001 in) to avoid divide-by-zero errors.`;
            errorDiv.style.display = "block";
            errorDiv.scrollIntoView({behavior:'smooth'});
            return;
        }
    }

    // --- Kinematic Stability Check ---
    let reactionCount = 0;
    sortedNodes.forEach(nd => {
        if (nd.type === "fixed") reactionCount += 2;
        else if (nd.type === "pin" || nd.type === "roller") reactionCount += 1;
    });

    if (reactionCount < 2) {
        errorDiv.innerText = "Unstable System: Fewer than 2 reaction components. Add supports to prevent free rotation/translation.";
        errorDiv.style.display = "block";
        return; 
    }

    const n = sortedNodes.length;
    const dof = 2 * n;
    let K = Array.from({length: dof}, () => new Array(dof).fill(0));
    let F_equiv = new Array(dof).fill(0);

    for (let i = 0; i < n - 1; i++) {
        const L = sortedNodes[i+1].x - sortedNodes[i].x;
        const EI = spans[i].E * spans[i].I;
        const k_loc = [
            [12*EI/(L**3), 6*EI/(L**2), -12*EI/(L**3), 6*EI/(L**2)],
            [6*EI/(L**2), 4*EI/L, -6*EI/(L**2), 2*EI/L],
            [-12*EI/(L**3), -6*EI/(L**2), 12*EI/(L**3), -6*EI/(L**2)],
            [6*EI/(L**2), 2*EI/L, -6*EI/(L**2), 4*EI/L]
        ];
        const idx = [2*i, 2*i+1, 2*(i+1), 2*(i+1)+1];
        for (let r=0; r<4; r++) for (let c=0; c<4; c++) K[idx[r]][idx[c]] += k_loc[r][c];
        
        const q1 = spans[i].q1, q2 = spans[i].q2;
        F_equiv[2*i] += (7*q1 + 3*q2)*L/20;
        F_equiv[2*i+1] += (3*q1 + 2*q2)*(L**2)/60;
        F_equiv[2*(i+1)] += (3*q1 + 7*q2)*L/20;
        F_equiv[2*(i+1)+1] -= (2*q1 + 3*q2)*(L**2)/60;
    }

    let F_total = [...F_equiv];
    sortedNodes.forEach((nd, i) => { 
        F_total[2*i] += nd.P; 
        F_total[2*i+1] += nd.M; 
    });

    let active = [];
    sortedNodes.forEach((nd, i) => {
        if (nd.type === "none") active.push(2*i, 2*i+1);
        else if (nd.type === "pin" || nd.type === "roller") active.push(2*i+1);
    });

    if (active.length > 0) {
        let K_sub = active.map(r => active.map(c => K[r][c]));
        let F_sub = active.map(r => F_total[r]);
        let U_res = solveLinear(K_sub, F_sub);
        let U_full = new Array(dof).fill(0);
        active.forEach((d, idx) => U_full[d] = U_res[idx]);

        let reactions = new Array(dof).fill(0);
        for(let i=0; i<dof; i++){
            let ku = 0;
            for(let j=0; j<dof; j++) ku += K[i][j] * U_full[j];
            reactions[i] = ku - F_total[i];
        }

        displayReactions(sortedNodes, reactions);
        updateCharts(sortedNodes, U_full, spans);
    }
}

function displayReactions(nodes, R) {
    const container = document.getElementById("reactionsDisplay");
    const list = document.getElementById("reactionsList");
    list.innerHTML = "";
    let found = false;
    nodes.forEach((nd, i) => {
        if (nd.type !== "none") {
            found = true;
            let text = `Node ${nd.id}: `;
            if (nd.type === "fixed") text += `Fy=${formatVal(R[2*i])} lb, M=${formatVal(R[2*i+1])} lb-in`;
            else text += `Fy=${formatVal(R[2*i])} lb`;
            const div = document.createElement("div");
            div.className = "reaction-item";
            div.innerText = text;
            list.appendChild(div);
        }
    });
    container.style.display = found ? "block" : "none";
}

function updateCharts(nodes, U, spans) {
    let data = { x: [], v: [], m: [], s: [], stress: [] };
    const xMin = nodes[0].x, xMax = nodes[nodes.length-1].x;
    const steps = 400;
    for (let i = 0; i <= steps; i++) {
        let xVal = xMin + (xMax - xMin) * i / steps;
        let e = nodes.findIndex((n, idx) => xVal >= n.x && xVal <= (nodes[idx+1]?.x || Infinity));
        if (e === -1 || e === nodes.length - 1) e = nodes.length - 2;
        
        const xStart = nodes[e].x, L = nodes[e+1].x - xStart, x = xVal - xStart, xi = x / L;
        const ue = [U[2*e], U[2*e+1], U[2*(e+1)], U[2*(e+1)+1]];
        const EI = spans[e].E * spans[e].I;
        const q1 = spans[e].q1, q2 = spans[e].q2;

        const v_h = (1 - 3*(xi**2) + 2*(xi**3))*ue[0] + L*(xi - 2*(xi**2) + xi**3)*ue[1] + (3*(xi**2) - 2*(xi**3))*ue[2] + L*(-(xi**2) + xi**3)*ue[3];
        const m_h = (EI/(L**2)) * ((-6 + 12*xi)*ue[0] + L*(-4 + 6*xi)*ue[1] + (6 - 12*xi)*ue[2] + L*(-2 + 6*xi)*ue[3]);
        const s_h = (EI/(L**3)) * (12*ue[0] + 6*L*ue[1] - 12*ue[2] + 6*L*ue[3]);

        const C1 = -(7*q1 + 3*q2)*L / 20; 
        const C2 = (3*q1 + 2*q2)*(L**2) / 60;
        const v_p = (1/EI) * (q1*(x**4)/24 + (q2-q1)*(x**5)/(120*L) + C1*(x**3)/6 + C2*(x**2)/2);
        const m_p = q1*(x**2)/2 + (q2-q1)*(x**3)/(6*L) + C1*x + C2;
        const s_p = q1*x + (q2-q1)*(x**2)/(2*L) + C1;

        const v = v_h + v_p;
        const mom = m_h + m_p;
        const shr = s_h + s_p;
        const stress = (-mom * spans[e].y) / spans[e].I;

        data.x.push(parseFloat(xVal.toFixed(3))); data.v.push(v); data.m.push(mom); data.s.push(shr); data.stress.push(stress);
    }
    renderChart('dispChart', data.x, data.v, '#007bff');
    renderChart('shearChart', data.x, data.s, '#dc3545');
    renderChart('momentChart', data.x, data.m, '#ffc107');
    renderChart('stressChart', data.x, data.stress, '#28a745');
}

function renderChart(id, x, y, color) {
    const maxVal = Math.max(...y), minVal = Math.min(...y);
    const maxIdx = y.indexOf(maxVal), minIdx = y.indexOf(minVal);
    const xMin = x[0], xMax = x[x.length-1];
    if (charts[id]) charts[id].destroy();
    charts[id] = new Chart(document.getElementById(id), {
        type: 'line',
        data: { labels: x, datasets: [{ data: y, borderColor: color, borderWidth: 1.5, pointRadius: 0 }] },
        options: { 
            responsive: true, maintainAspectRatio: false,
            layout: { padding: { top: 20, bottom: 20, right: 40 } },
            plugins: { legend: { display: false } },
            scales: { 
                x: { type: 'linear', display: true, min: xMin, max: xMax, grid: { color: 'rgba(0,0,0,0.06)', drawTicks: false }, ticks: { display: false } }, 
                y: { grid: { color: 'rgba(0,0,0,0.06)' }, ticks: { font: { size: 9 }, callback: formatVal, maxTicksLimit: 6 } } 
            }
        },
        plugins: [{
            id: 'peakDetector',
            afterDraw: (chart) => {
                const {ctx, scales: {x, y}} = chart;
                ctx.font = "bold 9px Arial"; ctx.fillStyle = "#333";
                [maxIdx, minIdx].forEach(idx => {
                    const val = chart.data.datasets[0].data[idx];
                    const px = x.getPixelForValue(chart.data.labels[idx]);
                    const py = y.getPixelForValue(val);
                    if (px < 40) ctx.textAlign = "left"; else if (px > chart.width - 40) ctx.textAlign = "right"; else ctx.textAlign = "center";
                    ctx.fillText(formatVal(val), px, py + (val >= 0 ? -10 : 15));
                });
            }
        }]
    });
}

function drawInputBeam(nodes, spans) {
    const canvas = document.getElementById('beamCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const pad = 60, xMin = nodes[0].x, xMax = nodes[nodes.length-1].x;
    const range = xMax - xMin || 1, scale = (canvas.width - 2*pad) / range, base = 130;
    
    // Grid Lines
    ctx.strokeStyle = '#f1f5f9'; ctx.lineWidth = 1;
    for(let i=0; i<=10; i++) {
        const gx = pad + (i * range/10) * scale;
        ctx.beginPath(); ctx.moveTo(gx, 20); ctx.lineTo(gx, base + 40); ctx.stroke();
    }
    
    // Main Beam Core
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 4; ctx.lineCap = "round";
    ctx.beginPath(); ctx.moveTo(pad, base); ctx.lineTo(canvas.width - pad, base); ctx.stroke();

    // Distributed Loads Visualization
    let maxAbsQ = 0; spans.forEach(s => maxAbsQ = Math.max(maxAbsQ, Math.abs(s.q1), Math.abs(s.q2)));
    const qDrawScale = maxAbsQ === 0 ? 0 : 35 / maxAbsQ;
    spans.forEach((s, i) => {
        if (s.q1 !== 0 || s.q2 !== 0) {
            const x1 = pad + (nodes[i].x - xMin) * scale, x2 = pad + (nodes[i+1].x - xMin) * scale;
            const y1 = base - (s.q1 * qDrawScale), y2 = base - (s.q2 * qDrawScale);
            ctx.fillStyle = "rgba(11, 100, 160, 0.1)"; ctx.strokeStyle = "rgba(11, 100, 160, 0.4)"; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(x1, base); ctx.lineTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x2, base); ctx.closePath(); ctx.fill(); ctx.stroke();
        }
    });

    nodes.forEach(nd => {
        const px = pad + (nd.x - xMin) * scale;
        
        // Node Marker Dot
        ctx.fillStyle = "#1e293b";
        ctx.beginPath(); ctx.arc(px, base, 3.5, 0, 7); ctx.fill();

        ctx.font = "bold 10px Inter, Arial"; ctx.textAlign = "center";
        ctx.fillText(`N${nd.id}`, px, base - 70);
        
        // Support Symbols
        ctx.strokeStyle = "#0b64a0"; ctx.lineWidth = 2;
        if (nd.type === "pin") { ctx.beginPath(); ctx.moveTo(px, base); ctx.lineTo(px-6, base+12); ctx.lineTo(px+6, base+12); ctx.closePath(); ctx.stroke(); }
        else if (nd.type === "roller") { ctx.beginPath(); ctx.arc(px, base+6, 5, 0, 7); ctx.stroke(); }
        else if (nd.type === "fixed") { ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(px, base-15); ctx.lineTo(px, base+15); ctx.stroke(); }
        
        // Concentrated Force Arrows
        if (nd.P !== 0) {
            ctx.strokeStyle = "#ef4444"; ctx.fillStyle = "#ef4444"; ctx.lineWidth = 2;
            const isD = nd.P < 0, sy = isD ? base - 50 : base + 50, ah = isD ? 6 : -6;
            ctx.beginPath(); ctx.moveTo(px, sy); ctx.lineTo(px, base); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(px, base); ctx.lineTo(px-3, base-ah); ctx.lineTo(px+3, base-ah); ctx.fill();
        }

        // Restored Moment Visualization (Arcs)
        if (nd.M !== 0) {
            ctx.strokeStyle = "#8b5cf6"; ctx.lineWidth = 2;
            const isCW = nd.M > 0;
            ctx.beginPath();
            ctx.arc(px, base, 22, isCW ? 1.2 * Math.PI : 1.3 * Math.PI, isCW ? 1.8 * Math.PI : 0.7 * Math.PI, !isCW);
            ctx.stroke();
            const tipX = px + 22 * Math.cos(isCW ? 1.8 * Math.PI : 0.7 * Math.PI);
            const tipY = base + 22 * Math.sin(isCW ? 1.8 * Math.PI : 0.7 * Math.PI);
            ctx.fillStyle = "#8b5cf6";
            ctx.beginPath(); ctx.arc(tipX, tipY, 3.5, 0, 7); ctx.fill();
        }
    });
}

function exportToCSV() {
    const { nodes, spans } = getData();
    let csv = "TYPE,ID_OR_LABEL,X_OR_E,TYPE_OR_I,P_OR_A,M_OR_Y,Q1,Q2\n";
    nodes.forEach(n => csv += `NODE,${n.id},${n.x},${n.type},${n.P},${n.M},,\n`);
    spans.forEach(s => csv += `SPAN,${s.label},${s.E},${s.I},0,${s.y},${s.q1},${s.q2}\n`);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'beam_analysis.csv'; a.click();
}

function importFromCSV(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const lines = e.target.result.split('\n').filter(line => line.trim() !== "");
        const dataLines = lines.slice(1);
        const nBody = document.querySelector("#nodeTable tbody");
        nBody.innerHTML = "";
        dataLines.forEach((line, i) => {
            const cols = line.split(',');
            if (cols[0] === 'NODE') {
                const row = nBody.insertRow();
                const delBtn = nBody.rows.length === 1 ? '' : `<button class="btn-del" onclick="removeRow(this)">×</button>`;
                row.innerHTML = `<td class="id-cell">${cols[1]}</td><td><input type="number" class="nx" value="${cols[2]}"></td><td><select class="nc"><option value="none" ${cols[3]=='none'?'selected':''}>None</option><option value="pin" ${cols[3]=='pin'?'selected':''}>Pin</option><option value="roller" ${cols[3]=='roller'?'selected':''}>Roller</option><option value="fixed" ${cols[3]=='fixed'?'selected':''}>Fixed</option></select></td><td><input type="number" class="np" value="${cols[4]}"></td><td><input type="number" class="nm" value="${cols[5]}"></td><td>${delBtn}</td>`;
            }
        });
        updateVisualization();
        const spanRows = document.querySelectorAll("#spanTable tbody tr");
        let sIdx = 0;
        dataLines.forEach(line => {
            const cols = line.split(',');
            if (cols[0] === 'SPAN' && spanRows[sIdx]) {
                const r = spanRows[sIdx++];
                r.querySelector(".se").value = cols[2]; r.querySelector(".si").value = cols[3];
                r.querySelector(".sy").value = cols[5]; r.querySelector(".sq1").value = cols[6]; r.querySelector(".sq2").value = cols[7];
            }
        });
        updateVisualization();
    };
    reader.readAsText(file);
}

window.onload = () => updateVisualization();
</script>
</body>
</html>